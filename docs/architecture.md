
# Architecture & Design

This document explains the structure of the IDs generated by **divortio-timeID** and why they are sortable.

## ID Composition

A standard unique identifier (generated by `TimeIDRandom`) is a composite string built from two distinct primitives:



```text
   [ TimeID ]      [ Random Suffix ]
 ┌────────────┐  ┌───────────────────┐
  0 8 k L _ 1 z 2  ~ 8 s 7 d 6 f 5 g 4
 └──────┬─────┘  └─────────┬─────────┘
     8 Chars            12+ Chars
   (Timestamp)         (Randomness)
````

* **Total Default Length:** 20 characters.
* **Bit Depth:** 48 bits (Time) + 72 bits (Random) = 120 bits (default).

### 1\. The Timestamp (`TimeID` Primitive)

The first 8 characters are generated by the `TimeID` class. This is a deterministic, reversible encoding of the timestamp.

* **Source:** Milliseconds since UNIX epoch.
* **Encoding:** Custom Base64 (6 bits per character).
* **Capacity:** $2^{48}$ milliseconds.
* **Lifespan:** This format allows storage of dates up to the year **10889 AD**.

### 2\. Randomness (`TimeIDRandom` Extension)

The suffix ensures that two IDs generated at the exact same millisecond do not collide.

* **Algorithm:** **SFC32** (Simple Fast Counter). This is a high-quality, chaotic PRNG that passes the "BigCrush" statistical test suite.
* **Entropy:** With the default length of 12 characters ($64^{12}$ combinations), the collision probability is negligible for most applications.

### Collision Probability

Within a **single millisecond**, the probability of generating two identical IDs depends on the length of the random suffix.

* **Suffix Length:** 12 characters (default)
* **Character Set Size:** 64
* **Total Combinations:** $64^{12} \approx 4.7 \times 10^{21}$ (4.7 Sextillion)

To have a **1% chance** of a collision within a *single millisecond*, you would need to generate approximately **300 billion IDs** in that same millisecond. For all practical purposes, collisions are impossible in standard distributed systems.

## Lexicographical Sorting

The key feature of this library is that **String Sorting == Time Sorting**.

Because the `TimeID` (timestamp) is placed at the **start** of the string, sorting these IDs alphabetically automatically groups them by creation time.

This is achieved by using a **Custom Character Dictionary** that aligns with the ASCII table order:

```text
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~
```

### Why this order?

Standard Base64 often uses `+` and `/`, which can sort inconsistently depending on the system. We use a URL-safe, ASCII-ordered set:

1.  **Numbers** (`0-9`) come first (ASCII 48-57).
2.  **Uppercase** (`A-Z`) come next (ASCII 65-90).
3.  **Underscore** (`_`) comes after uppercase (ASCII 95).
4.  **Lowercase** (`a-z`) come last (ASCII 97-122).
5.  **Tilde** (`~`) is the final character (ASCII 126).

By mapping earlier timestamps to "lower" characters in this specific sequence, we guarantee that `ID_Time_A < ID_Time_B` whenever `Time_A < Time_B`.

